/*jslint
    fudge
*/

import nil_type from "./Nil_Type.min.js";

import {
    compose,
    constant,
    identity,
    flip,
    pipeN
} from "@jlrwi/combinators";
import {
    equals,
    is_object,
    minimal_object,
    object_has_property,
    prop,
    andf,
    orf,
    either
} from "@jlrwi/esfunctions";

const nilT = nil_type ();

const type_name = "Maybe";

const extract = prop ("value");

const nothing = function (x) {
    return minimal_object({
        type_name: "Nothing",
        toJSON: constant ("Maybe.Nothing"),
        value: x
    });
};

const just = function (x) {
    return minimal_object({
        type_name: "Just",
        toJSON: constant ("Maybe.Just (" + JSON.stringify(x) + ")"),
        value: x
    });
};

// a -> M<a>
const create = either (nilT.validate) (nothing) (just);

const is_Just = compose (equals ("Just")) (prop ("type_name"));
const is_Nothing = compose (equals ("Nothing")) (prop ("type_name"));

/*
const is_Just = function (x) {
    if (!is_object (x) || !object_has_property ("type_name") (x)) {
        throw new TypeError("Not a Maybe value");
    }

    return (x.type_name === "Just");
};

const is_Nothing = function (x) {
    if (!is_object (x) || !object_has_property ("type_name") (x)) {
        throw new TypeError("Not a Maybe value");
    }

    return (x.type_name === "Nothing");
};
*/

// Setoid :: a -> a -> boolean
const adt_equals = function (T) {
    return function (y) {
        return function (x) {
            if (x.type_name === y.type_name) {
                return (
                    is_Nothing (x)
                    ? true
                    : T.equals (extract (x)) (extract (y))
                );
            }

            return false;
        };
    };
};

// Ord :: a -> a -> Boolean
const lte = function (T) {
    return function (y) {
        return function (x) {

            if (is_Nothing (x)) {
                return true;
            }

            if (is_Nothing (y)) {
                return false;
            }

            return T.lte (extract (y)) (extract (x));
        };
    };
};

// Semigroup :: a -> a -> a
const concat = function (T) {
    return function (y) {
        return function (x) {
            if (is_Nothing (x)) {
                return y;
            }

            if (is_Nothing (y)) {
                return x;
            }

            return just (T.concat (extract (y)) (extract (x)));
        };
    };
};

// Monoid :: () -> a
const empty = function () {
    return nothing ();
};

// Functor :: (a -> b) -> a -> b
const map = function (f) {
    return either (is_Nothing) (identity) (pipeN (
        extract,
        f,
        just
    ));
};

// Alt :: <a> -> <a> -> <a>
const alt = function (y) {
    return either (is_Nothing) (constant (y)) (identity);
};

// Plus :: () -> a
const zero = empty;

// Apply :: <(a -> b)> -> <a> -> <b>
const ap = function (mf) {
    return function (mx) {
        if (is_Nothing (mf) || is_Nothing (mx)) {
            return nothing ();
        }

        return just (extract (mf) (extract (mx)));
    };
};

// Applicative :: a -> <a>
const of = just;

// Chain :: (a -> <b>) -> <a> -> <b>
const chain = function (f) {
    return either (is_Nothing) (identity) (compose (f) (extract));
};

// Foldable :: ((b, a) -> b, b, <a>) -> b
const reduce = function (f) {
    return function (initial) {
        return function (x) {
            return (
                is_Nothing (x)
                ? initial
                : f (initial) (extract (x))
            );
        };
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> T<a> -> U<T<b>>
const traverse = function (to_T) {
    return function (f) {
        return function (x) {
            return (
                is_Nothing (x)
                ? to_T.of (x)
                : to_T.map (just) (f (extract (x)))
            );
        };
    };
};

// Filterable :: (a -> Boolean) -> <a> -> <a>
const filter = function (f) {
    return function (x) {
        if (is_Nothing (x)) {
            return x;
        }

        return (
            f (extract (x)) === true
            ? x
            : nothing ()
        );
    };
};

const validate = function (T) {
    return function (x) {
        if (!is_object (x) || !object_has_property("type_name")) {
            return false;
        }

        return (
            is_Just (x)
            ? T.validate (extract (x))
            : is_Nothing (x)
        );
    };
};

const type_factory = function (type_of) {
    const base_type = {
        spec: "StaticLand",
        version: 1,
        type_name,
        just,
        nothing,
        is_Just,
        is_Nothing,
        create,
        empty,
        reduce,
        map,
        alt,
        zero,
        ap,
        of,
        chain,
        traverse,
        filter,
        validate: andf (is_object) (orf (is_Just) (is_Nothing))
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        base_type.concat = concat (type_of);
        base_type.type_name += "< " + type_of.type_name + " >";

        if (check_for_prop ("equals")) {
            base_type.equals = adt_equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (type_of);
        }
    }

    return Object.freeze(base_type);
};








export default Object.freeze(type_factory);

