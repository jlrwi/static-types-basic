/*jslint
    fudge
*/

import {
    compose,
    constant,
    converge,
    flip
} from "@jlrwi/combinators";
import {
    and,
    andf,
    either,
    prop,
    is_object,
    minimal_object,
    object_has_property
} from "@jlrwi/esfunctions";

// Static Land implementation of Pair

const type_name = "Pair";

// Pair<a, b> -> a
const fst = prop ("fst");

// Pair<a, b> -> b
const snd = prop ("snd");

// a -> b -> Pair<a, b>
// Morphism between functors Function and Pair
const create = function (fst) {
    return function (snd) {
        return minimal_object ({
            toJSON: constant (
                "Pair (" + JSON.stringify(fst) + "," + JSON.stringify(snd) + ")"
            ),
            fst,
            snd
        });
    };
};

// Setoid :: T -> a -> a -> boolean
const equals = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return and (
                    spec_fst.equals (fst (xs)) (fst (ys))
                ) (
                    spec_snd.equals (snd (xs)) (snd (ys))
                );
            };
        };
    };
};

// Ord :: T -> a -> a -> boolean
const lte = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return (
                    spec_fst.equals (fst (ys)) (fst (xs))
                    ? spec_snd.lte (snd (ys)) (snd (xs))
                    : spec_fst.lte (fst (ys)) (fst (xs))
                );
            };
        };
    };
};

// Semigroup :: T -> a -> a -> a
const concat = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return create (
                    spec_fst.concat (fst (ys)) (fst (xs))
                ) (
                    spec_snd.concat (snd (ys)) (snd (xs))
                );
            };
        };
    };
};

// Monoid :: T -> _ -> a
const empty = function (spec_fst) {
    return function (spec_snd) {
        return function () {
            return create (spec_fst.empty ()) (spec_snd.empty ());
        };
    };
};

// Map, ap, reduce, and of are snd-biased

// Functor :: (a -> b) -> a -> b
const map = function (f) {
    return converge (create) (fst) (compose (f) (snd));
//    return function (x) {
//        return create (fst (x)) (f (snd (x)));
//    };
};

// Apply :: F<a->b> -> F<a> -> F<b>
// Must be given the spec types to harvest the concat function for fst
// Otherwise is not lawful (fails Interchange test)
const ap = function (spec_fst) {
    return function (ignore) {
        return function (fs) {
            return function (xs) {
                return create (
                    spec_fst.concat (fst (xs)) (fst (fs))
                ) (
                    snd (fs) (snd (xs))
                );
            };
        };
    };
};

// Applicative :: a -> F<a>
//const of = create ();
const of = function (spec_fst) {
    return function (ignore) {
        return create (spec_fst.empty ());
    };
};

// Bifunctor :: (a->b) -> (c->d) -> Pair<a, c> -> Pair<b, d>
const bimap = function (f) {
    return function (g) {
        return converge (create) (compose (f) (fst)) (compose (g) (snd));
//        return function (x) {
//            return create (f (fst (x)) (g (snd (x)));
//        };
    };
};

// Chain :: (b -> (a, c)) -> (a, b) -> (a, c)
const chain = function (spec_fst) {
    return function (ignore) {
        return function (f) {
            const apply_f = compose (f) (snd);
            const to_fst = converge (spec_fst.concat) (
                fst
            ) (
                compose (fst) (apply_f)
            );
            const to_snd = compose (snd) (apply_f);
            return converge (create) (to_fst) (to_snd);
        };
    };
};

// Extend :: ((a, b)-> c) -> (a, b) -> (a, c)
const extend = function (f) {
    return converge (create) (fst) (f);
};

const extract = snd;

// Foldable :: ((b, a) -> b, b, <a>) -> b
const reduce = function (f) {
    return function (acc) {
        return function (x) {
            return f (acc) (snd (x));
        };
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> T<a> -> U<T<b>>
const traverse = function (to_T) {
    return function (f) {
        return converge (
            to_T.map
        ) (
            compose (create) (fst)
        ) (
            compose (f) (snd)
        );
    };
};

// Semigroupoid :: (a, b) -> (b, c) -> (a, c)
const adt_compose = function (pairA) {
    return function (pairB) {
        return create (fst (pairA)) (snd (pairB));
    };
};

const validate = function (fstT) {
    return function (sndT) {
        return either (is_object) (
            andf (compose (fstT.validate) (fst)) (compose (sndT.validate) (snd))
        ) (
            constant (false)
        );
//        return function (x) {
//            return (
//                is_object (x)
//                ? fstT.validate (fst (x)) && sndT.validate (snd (x))
//                : false
//            );
//        };
    };
};

const type_factory = function (spec_fst) {
    return function (spec_snd) {
        const base_type = {
            spec: "StaticLand",
            version: 1,
            type_name,
            fst,
            snd,
            bimap,
            create,
            validate: either (is_object) (
                andf (object_has_property ("fst")) (object_has_property ("snd"))
            ) (
                constant (false)
            ),
            reduce,
            map,
            of: create (),
            traverse,
            extend,
            extract,
            compose: adt_compose
        };

        if (is_object (spec_fst) && is_object (spec_snd)) {

            const check_for_prop = and (
                flip (object_has_property) (spec_fst)
            ) (
                flip (object_has_property) (spec_snd)
            );

            if (check_for_prop ("equals")) {
                base_type.equals = equals (spec_fst) (spec_snd);
            }

            if (check_for_prop ("lte")) {
                base_type.lte = lte (spec_fst) (spec_snd);
            }

            if (check_for_prop ("concat")) {
                base_type.concat = concat (spec_fst) (spec_snd);
                base_type.ap = ap (spec_fst) (spec_snd);
                base_type.chain = chain (spec_fst) (spec_snd);
            }

            if (check_for_prop ("empty")) {
                base_type.empty = empty (spec_fst) (spec_snd);
                base_type.of = of (spec_fst) (spec_snd);
            }

            if (check_for_prop ("validate")) {
                base_type.validate = validate (spec_fst) (spec_snd);
            }

            base_type.type_name += "<" +
                spec_fst.type_name + ", " + spec_snd.type_name +
            ">";
        }

        return base_type;
    };
};


export default Object.freeze(type_factory);
