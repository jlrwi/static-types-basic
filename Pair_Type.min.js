/*jslint
    unordered
*/

import {
    compose,
    constant,
    converge,
    converge2,
    flip
} from "@jlrwi/combinators";
import {
    and,
    andf,
    or,
    functional_if,
    prop,
    is_object,
    minimal_object,
    object_has_property
} from "@jlrwi/esfunctions";

// Static Land implementation of Pair

const type_name = "Pair";

// a -> b -> Pair<a, b>
// Morphism between functors Function and Pair
const create = function (fst) {
    return function (snd) {
        return minimal_object({
            type_name,
            toJSON: constant(
                "Pair (" + JSON.stringify(fst) + "," + JSON.stringify(snd) + ")"
            ),
            fst,
            snd
        });
    };
};

// Pair<a, b> -> a
const fst = prop("fst");

// Pair<a, b> -> b
const snd = prop("snd");

// Setoid :: T -> a -> a -> boolean
const equals = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return and(
                    spec_fst.equals(fst(xs))(fst(ys))
                )(
                    spec_snd.equals(snd(xs))(snd(ys))
                );
            };
        };
    };
};

// T -> T -> x -> a -> boolean
const includes = function (spec_fst) {
    return function (spec_snd) {
        return function (x) {
            return converge2(
                or
            )(
                compose(spec_fst.equals(x))(fst)
            )(
                compose(spec_snd.equals(x))(snd)
            );
        };
    };
};

// Ord :: T -> a -> a -> boolean
const lte = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return (
                    spec_fst.equals(fst(ys))(fst(xs))
                    ? spec_snd.lte(snd(ys))(snd(xs))
                    : spec_fst.lte(fst(ys))(fst(xs))
                );
            };
        };
    };
};

// Semigroup :: T -> a -> a -> a
const concat = function (spec_fst) {
    return function (spec_snd) {
        return function (ys) {
            return function (xs) {
                return create(
                    spec_fst.concat(fst(ys))(fst(xs))
                )(
                    spec_snd.concat(snd(ys))(snd(xs))
                );
            };
        };
    };
};

// Monoid :: T -> _ -> a
const empty = function (spec_fst) {
    return function (spec_snd) {
        return converge(create)(spec_fst.empty)(spec_snd.empty);
    };
};

// Map, ap, reduce, and of are snd-biased

// Functor :: (a -> b) -> a -> b
const map = function (f) {
    return converge(create)(fst)(compose(f)(snd));
};

// Apply :: F<a->b> -> F<a> -> F<b>
// Must be given the spec types to harvest the concat function for fst
// Otherwise is not lawful (fails Interchange test)
const ap = function (spec_fst) {
    return function (ignore) {
        return function (fs) {
            return function (xs) {
                return create(
                    spec_fst.concat(fst(xs))(fst(fs))
                )(
                    snd(fs)(snd(xs))
                );
            };
        };
    };
};

// Applicative :: a -> F<a>
const of = function (spec_fst) {
    return function (ignore) {
        return create(spec_fst.empty());
    };
};

// Chain :: (b -> (a, c)) -> (a, b) -> (a, c)
const chain = function (spec_fst) {
    return function (ignore) {
        return function (f) {
            return function (x) {
// Get the result of applying f to snd
                const apply_f = f(snd(x));

                return create(
// Concat the original fst and the resulting fst
                    spec_fst.concat(fst(x))(fst(apply_f))
                )(
// Use the resulting snd
                    snd(apply_f)
                );
/*
// f is applied to snd
            const apply_f = compose(f)(snd);

            const to_fst = converge(
                spec_fst.concat
            )(
                fst
            )(
                compose(fst)(apply_f)
            );

// Retrieve the snd value the result of apply_f
            const to_snd = compose(snd)(apply_f);
            return converge(create)(to_fst)(to_snd);
*/
            };
        };
    };
};

// Bifunctor :: (a->b) -> (c->d) -> Pair<a, c> -> Pair<b, d>
const bimap = function (f) {
    return function (g) {
        return converge(create)(compose(f)(fst))(compose(g)(snd));
    };
};

// Extend :: ((a, b)-> c) -> (a, b) -> (a, c)
const extend = function (f) {
    return converge(create)(fst)(f);
};

// Comonad :: (a, b) -> b
const extract = snd;

// Foldable :: ((b, a) -> b, b, <a>) -> b
const reduce = function (f) {
    return function (acc) {
        return compose(f(acc))(snd);
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> (c, a) -> U<(c, b)>
const traverse = function (to_T) {
    return function (f) {
        return converge(
            to_T.map
        )(
            compose(create)(fst)
        )(
            compose(f)(snd)
        );
    };
};

// Semigroupoid :: (a, b) -> (b, c) -> (a, c)
const adt_compose = function (pairA) {
    return function (pairB) {
        return create(fst(pairA))(snd(pairB));
    };
};

// New fx - keep it?
const toArray = function (pair) {
    return [fst(pair), snd(pair)];
};

const validate = function (fstT) {
    return function (sndT) {
        return function (x) {
            return (
                is_object(x)
                ? fstT.validate(fst(x)) && sndT.validate(snd(x))
                : false
            );
        };
    };
};

const type_factory = function (spec_fst) {
    return function (spec_snd) {
        const base_type = {
            spec: "curried-static-land",
            version: 1,
            type_name,
            fst,
            snd,
            bimap,
            create,
            validate: functional_if(
                is_object
            )(
                andf(object_has_property("fst"))(object_has_property("snd"))
            )(
                constant(false)
            ),
            reduce,
            map,
            of: create(),
            traverse,
            extend,
            extract,
            compose: adt_compose,
            toArray
        };

        if (is_object(spec_fst) && is_object(spec_snd)) {

            const check_for_prop = and(
                flip(object_has_property)(spec_fst)
            )(
                flip(object_has_property)(spec_snd)
            );

            if (check_for_prop("equals")) {
                base_type.equals = equals(spec_fst)(spec_snd);
                base_type.includes = includes(spec_fst)(spec_snd);
            }

            if (check_for_prop("lte")) {
                base_type.lte = lte(spec_fst)(spec_snd);
            }

            if (check_for_prop("concat")) {
                base_type.concat = concat(spec_fst)(spec_snd);
                base_type.ap = ap(spec_fst)(spec_snd);
                base_type.chain = chain(spec_fst)(spec_snd);
            }

            if (check_for_prop("empty")) {
                base_type.empty = empty(spec_fst)(spec_snd);
                base_type.of = of(spec_fst)(spec_snd);
            }

            if (check_for_prop("validate")) {
                base_type.validate = validate(spec_fst)(spec_snd);
            }

            base_type.type_name += "<" +
                spec_fst.type_name + ", " + spec_snd.type_name +
            ">";
        }

        return base_type;
    };
};

export default Object.freeze(type_factory);
