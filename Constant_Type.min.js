/*jslint
    fudge
*/

/*
Attempts to make this type function as an Applicative using straightforward
logic don't succeed in passing the tests.

If Constant is instantiated with a monoid, it can be derived to behave like an
Applicative, using .concat() for .ap(), and .empty() for .of()

This allows the sort-of Applicative to be used with traversal functions, with
different monoids (eg arrays vs. numbers) producing different results.

References:
Sanctuary Constant:
https://github.com/sanctuary-js/sanctuary-constant/

Explanation of partial lenses
https://calmm-js.github.io/partial.lenses/implementation.html
*/

import {
    constant,
    compose,
    compose2,
    flip,
    on,
    second
} from "@jlrwi/combinators";
import {
    is_object,
    prop,
    object_has_property,
    minimal_object
} from "@jlrwi/esfunctions";

const type_name = "Constant";

const extract = prop ("value");

const empty = function (T) {
    return compose (create) (T.empty);
};

const concat = function (T) {
    return compose2 (create) (on (T.concat) (extract));
};

const adt_equals = function (T) {
    return on (T.equals) (extract);
};

const lte = function (T) {
    return on (T.lte) (extract);
};

// Discard the f parameter and just return the unchanged Constant
const map = second;

// Ignore the instance containing the function and return the sedond
const ap = second;

// Foldable :: ((b, a) -> b) -> b -> C a -> b
//                ignored               ignored
const reduce = function (ignore) {
    return constant;
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> C a -> U<C b>
//                                    ignored
const traverse = function (U) {
    return function (ignore) {
        return U.of;
    };
};

const validate = function (T) {
    return function (x) {
        return (
            is_object (x)
            ? T.validate (x.value)
            : false
        );
    };
};

const create = function (x) {
    return minimal_object({
        type_name,
        toJSON: constant ("Constant (" + JSON.stringify(x) + ")"),
        value: x
    });
};

const type_factory = function (type_of) {
    const base_type = {
        spec: "StaticLand",
        version: 1,
        type_name,
        ap,
        map,
        create,
        reduce,
        traverse,
        validate: is_object,
        extract
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("concat")) {
            base_type.concat = concat (type_of);
            base_type.ap = base_type.concat;
        }

        if (check_for_prop ("empty")) {
            base_type.empty = empty (type_of);
            base_type.of = base_type.empty;
        }

        if (check_for_prop ("equals")) {
            base_type.equals = adt_equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
