/*jslint
    fudge
*/

import {
    constant,
    flip,
    on,
    pipeN
} from "@jlrwi/combinators";
import {
    is_object,
    prop,
    object_has_property,
    minimal_object
} from "@jlrwi/esfunctions";

const type_name = "Identity";

const extract = prop ("value");

const of = function (x) {
    return minimal_object({
        type_name,
        toJSON: constant ("Identity (" + JSON.stringify(x) + ")"),
        value: x
    });
};

const concat = function (T) {
// Doesn't work because on is waiting for two more inputs
//    return compose (of) (on (T.concat) (extract));
    return function (y) {
        return function (x) {
            return of (T.concat (extract (x)) (extract (y)));
        };
    };
};

const empty = function (spec) {
    return function () {
        return of (spec.empty ());
    };
};

const equals = function (T) {
    return on (T.equals) (extract);
//    return function (x) {
//        return function (y) {
//            return T.equals (extract (x)) (extract (y));
//        };
//    };
};

const lte = function (T) {
    return on (T.lte) (extract);
//    return function (y) {
//        return function (x) {
//            return T.lte (extract (y)) (extract (x));
//        };
//    };
};

const map = function (f) {
    return pipeN (
        extract,
        f,
        of
    );
};

//const ap = compose (map) (extract);
const ap = function (a) {
    return map (extract (a));
};

const validate = function (T) {
    return function (x) {
        return (
            is_object (x)
            ? T.validate (extract (x))
            : false
        );
    };
};

const create = of;

const type_factory = function (type_of) {
    const base_type = {
        spec: "StaticLand",
        version: 1,
        type_name,
        ap,
        map,
        of,
        create,
        validate: is_object,
        extract
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("concat")) {
            base_type.concat = concat (type_of);
        }

        if (check_for_prop ("empty")) {
            base_type.empty = empty (type_of);
        }

        if (check_for_prop ("equals")) {
            base_type.equals = equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};





export default Object.freeze(type_factory);
