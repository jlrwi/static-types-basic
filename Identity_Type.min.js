/*jslint
    unordered
*/

import {
    constant,
    compose,
    flip,
    on,
    pipe,
    pipeN
} from "@jlrwi/combinators";
import {
    is_object,
    andf,
    functional_if,
    prop,
    object_has_property,
    minimal_object
} from "@jlrwi/esfunctions";

// Comonad :: <a> -> a
const type_name = "Identity";

const extract = prop("value");

const create = function (x) {
    return minimal_object({
        type_name,
        toJSON: constant("Identity (" + JSON.stringify(x) + ")"),
        value: x
    });
};

// Semigroup :: <a> -> <a> -> <a>
const concat = function (T) {
    return function (y) {
        return function (x) {
            return of(T.concat(extract(y))(extract(x)));
        };
    };
};

// Monoid :: () -> <a>
const empty = function (spec) {
    return compose(of)(spec.empty);
};

// Setoid :: <a> -> <a> -> boolean
const adt_equals = function (T) {
    return on(T.equals)(extract);
};

// Ord :: <a> -> <a> -> boolean
const lte = function (T) {
    return on(T.lte)(extract);
};

// Functor :: (a -> b) -> <a> -> <b>
const map = function (f) {
    return pipeN(
        extract,
        f,
        of
    );
};

// Apply :: <a -> b> -> <a> -> <b>
const ap = compose(map)(extract);

// Applicative :: a -> <a>
const of = create;

// Extend :: (<a> -> b) -> <a> -> <b>
const extend = compose(of);

// Foldable :: ((b, a) -> b) -> b -> C a -> b
const reduce = function (f) {
    return function (initial_value) {
        return compose(f(initial_value))(extract);
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> C a -> U<C b>
const traverse = function (U) {
    return function (f) {
        return pipe(
            compose(f)(extract)
        )(
            U.map(of)
        );
    };
};

const validate = function (T) {
    return functional_if(
        andf(object_has_property("value"))(is_object)
    )(
        compose(T.validate)(extract)
    )(
        constant(false)
    );
};

const type_factory = function (type_of) {
    const base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name,
        ap,
        extend,
        map,
        of,
        reduce,
        traverse,
        create,
        validate: andf(object_has_property("value"))(is_object),
        extract
    };

    if (is_object(type_of)) {

        const check_for_prop = flip(object_has_property)(type_of);

        if (check_for_prop("concat")) {
            base_type.concat = concat(type_of);
        }

        if (check_for_prop("empty")) {
            base_type.empty = empty(type_of);
        }

        if (check_for_prop("equals")) {
            base_type.equals = adt_equals(type_of);
        }

        if (check_for_prop("lte")) {
            base_type.lte = lte(type_of);
        }

        if (check_for_prop("validate")) {
            base_type.validate = validate(type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
