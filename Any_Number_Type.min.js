/*jslint
    fudge
*/

import {
    constant
} from "@jlrwi/combinators";
import {
    is_object,
    minimal_object
} from "@jlrwi/esfunctions";

const type_name = "Any Number";

const create = function (r = 0, i = 0) {
    return minimal_object({
        type_name,
        toJSON: constant ("Any Number (" +
            JSON.stringify(r) + " + " + JSON.stringify(i) + "i" +
        ")"),
        r,
        i
    });
};

const concat = function (y) {
    return function (x) {
        return create (y.r + x.r, y.i + x.i);
    };
};

const empty = function () {
    return create (0, 0);
};

const invert = function (x) {
    return create (0 - x.r, 0 - x.i);
};

const adt_equals = function (x) {
    return function (y) {
        return ((x.r === y.r) && (x.i === y.i));
    };
};

const lte = function (y) {
    return function (x) {
        return ((x.r**2 + x.i**2) <= (y.r**2 + y.i**2));
    };
};

const map = function (f) {
    return function (x) {
        return create (f(x.r), f(x.i));
    };
};

// Bifunctor :: (a->b) -> (c->d) -> Pair<a, c> -> Pair<b, d>
const bimap = function (f) {
    return function (g) {
        return function (x) {
            return create (f(x.r), g(x.i));
        };
    };
};

const validate = function (x) {
    return (
        is_object (x)
        ? ((x.r !== undefined) && (x.i !== undefined))
        : false
    );
};

const type_factory = function (ignore) {
    return Object.freeze({
        spec: "StaticLand",
        version: 1,
        type_name,
        concat,
        empty,
        invert,
        equals: adt_equals,
        lte,
        map,
        bimap,
        create,
        validate
    });
};

export default Object.freeze(type_factory);
