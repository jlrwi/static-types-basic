/*jslint
    fudge
*/

import nil_type from "./Nil_Type.min.js";
 
import {
    constant,
    compose,
    flip
} from "@jlrwi/combinators";
import {
    andf,
    orf,
    equals,
    is_object,
    prop,
    object_has_property,
    minimal_object
} from "@jlrwi/esfunctions";

const nilT = nil_type ();
const type_name = "Either";

const extract = prop ("value");

const left = function (x) {
    return minimal_object({
        type_name: "Left",
        toJSON: constant ("Either.left (" + JSON.stringify(x) + ")"),
        value: x
    });
};

const right = function (x) {
    return minimal_object({
        type_name: "Right",
        toJSON: constant ("Either.right (" + JSON.stringify(x) + ")"),
        value: x
    });
};

// a -> b -> Either<a b>
const create = function (left_value) {
    return function (right_value) {
        return (
            nilT.validate (left_value)
            ? right (right_value)
            : left (left_value)
        );
    };
};

//const is_right = function (x) {
//    return x.type_name === "Right";
//};
const is_right = compose (equals ("Right")) (prop ("type_name"));
const is_left = compose (equals ("Left")) (prop ("type_name"));

//const is_left = function (x) {
//    return x.type_name === "Left";
//};

// Setoid :: (T -> T) -> a -> a -> boolean
const adt_equals = function (T_fst) {
    return function (T_snd) {
        return function (x) {
            return function (y) {
                if (x.type_name === y.type_name) {
                    const useT = (
                        is_right (x)
                        ? T_snd
                        : T_fst
                    );
                    return useT.equals (extract (x)) (extract (y));
                }
                return false;
            };
        };
    };
};

// Ord :: ((T) -> (T)) -> a -> a -> Boolean
// Reads lte y is x?
const lte = function (T_fst) {
    return function (T_snd) {
        return function (y) {
            return function (x) {
                if (x.type_name === y.type_name) {
                    const useT = (
                        is_right (x)
                        ? T_snd
                        : T_fst
                    );
                    return useT.lte (extract (y)) (extract (x));
                }
                return is_left (x); // Left is always lte Right
            };
        };
    };
};

// Functor :: (a -> b) -> F<a> -> F<b>
const map = function (f) {
    return function (x) {
        return (
            is_right (x)
            ? right (f (extract (x)))
            : x
        );
    };
};

// Alt :: <a> -> <a> -> <a>
const alt = function (x) {
    return function (y) {
        return (
            is_right (x)
            ? x
            : y
        );
    };
};

// Apply :: F<(a -> b)> -> F<a> -> F<b>
const ap = function (ff) {
    return function (fx) {
        if (is_right (ff)) {
            return (
                is_right (fx)
                ? right (extract (ff) (extract (fx)))
                : fx
            );
        }

        // If 'fx' parameter is Left, just return it
        return ff;
    };
};

// Applicative :: a -> <a>
const of = right;

// Chain :: (a -> <b>) -> <a> -> <b>
const chain = function (f) {
    return function (ex) {
        return (
            is_right (ex)
            ? f (extract (ex))
            : ex
        );
    };
};

// Bifunctor :: (a->b) -> (c->d) -> Either<a, c> -> Either<b, d>
const bimap = function (f) {
    return function (g) {
        return function (x) {
            return (
                is_right (x)
                ? right (g (extract (x)))
                : left (f (extract (x)))
            );
        };
    };
};

// Extend :: (Either <a b> -> c) -> Either <a b> -> Either <a c>
const extend = function (f) {
    return function (x) {
        return (
            is_right (x)
            ? right (f (x))
            : x
        );
    };
};

// Foldable :: ((b, a) -> b, b, <a>) -> b
const reduce = function (f) {
    return function (initial) {
        return function (x) {
            return (
                is_right (x)
                ? f (initial) (extract (x))
                : initial
            );
        };
    };
};

// Semigroup :: (T -> T) -> a -> a -> a
const concat = function (T_fst) {
    return function (T_snd) {
        return function (x) {
            return function (y) {
                if (x.type_name === y.type_name) {
                    if (is_right (x)) {
                        return right (T_snd.concat (extract (x)) (extract (y)));
                    }

                    return left (T_fst.concat (extract (x)) (extract (y)));
                }

                return (
                    is_right (x)
                    ? x
                    : y
                );
            };
        };
    };
};

// Monoid can't pass tests with a Left

// Traversable :: Applicative<U> -> (a -> U<b>) -> T<a> -> U<T<b>>
const traverse = function (to_T) {
    return function (f) {
        return function (x) {
            return (
                is_right (x)
                ? to_T.map (right) (f (extract (x)))
                : to_T.of (x)
            );
        };
    };
};

// a -> boolean
const validate = function (type_fst) {
    return function (type_snd) {
        return function (x) {
            return (
                is_right (x)
                ? type_snd.validate (extract (x))
                : type_fst.validate (extract (x))
            );
        };
    };
};

// Sanctuary has ord, chainrec
const type_factory = function (spec_left) {
    return function (spec_right) {
        const base_type = {
            spec: "StaticLand",
            version: 1,
            type_name,
            left,
            right,
            is_right,
            is_left,
            reduce,
            map,
            alt,
            ap,
            of,
            chain,
            traverse,
            bimap,
            extend,
            create,
            validate: andf (orf (is_right) (is_left)) (is_object)
        };

        if (is_object (spec_left) && is_object (spec_right)) {

            const check_for_prop = andf (
                flip (object_has_property) (spec_left)
            ) (
                flip (object_has_property) (spec_right)
            );

            if (check_for_prop ("concat")) {
                base_type.concat = concat (spec_left) (spec_right);
            }

            if (check_for_prop ("equals")) {
                base_type.equals = adt_equals (spec_left) (spec_right);
            }

            if (check_for_prop ("lte")) {
                base_type.lte = lte (spec_left) (spec_right);
            }

            if (check_for_prop ("validate")) {
                base_type.validate = validate (spec_left) (spec_right);
            }

            base_type.type_name += "< " +
                spec_left.type_name + "||" + spec_right.type_name +
            " >";
        }

        return Object.freeze(base_type);
    };
};







export default Object.freeze(type_factory);

