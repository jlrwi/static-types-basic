/*jslint
    unordered
*/

import {
    compose,
    constant,
    converge
} from "@jlrwi/combinators";
import {
    andf,
    gte,
    negate,
    type_check,
    prop,
    is_object,
    functional_if,
    minimal_object
} from "@jlrwi/esfunctions";

// Static Land implementation of Vector

const type_name = "Vector";

const angle_constrain = function (min, max) {
    const offset = max - min;

    const simplify = function (angle) {

        if (angle >= max) {
            return simplify(angle - offset);
        }

        if (angle < min) {
            return simplify(angle + offset);
        }

        return angle;
    };

    return simplify;
};

const constrain_pi = angle_constrain(negate(Math.PI), Math.PI);

// a -> b -> Pair<a, b>
const create = function (magnitude) {
    return function (angle) {
        return minimal_object({
            toJSON: constant(
                `Vector ${JSON.stringify(magnitude)} @ ${JSON.stringify(angle)}`
            ),
            magnitude,
            angle
        });
    };
};

// Setoid :: T -> a -> a -> boolean
const equals = function (y) {
    return function (x) {
        return ((
            x.magnitude === y.magnitude
        ) && (
            (x.magnitude === 0)
            ? true
            : constrain_pi(x.angle) === constrain_pi(y.angle)
        ));
    };
};

// Semigroup :: T -> a -> a -> a
// x is added onto y
const concat = function (y) {
    return function (x) {
        const new_x = (
            y.magnitude * Math.cos(y.angle)
        ) + (
            x.magnitude * Math.cos(x.angle)
        );

        const new_y = (
            y.magnitude * Math.sin(y.angle)
        ) + (
            x.magnitude * Math.sin(x.angle)
        );

        const magnitude = Math.sqrt(new_x**2 + new_y**2);

        return create(
            magnitude
        )(
            (magnitude === 0)
            ? 0
            : constrain_pi(Math.acos(new_x / magnitude)) * Math.sign(new_y)
        );
    };
};

// Monoid :: T -> _ -> a
const empty = function () {
    return create(0)(0);
};

// Group :: a -> a
const invert = function ({magnitude, angle}) {
    return create(
        magnitude
    )(
        (angle < Math.PI)
        ? angle + Math.PI
        : angle - Math.PI
    );
};

// Functor :: (a -> b) -> a -> b
const map = function (f) {
    return converge(
        create
    )(
        compose(f)(prop("magnitude"))
    )(
        prop("angle")
    );
};

// Bifunctor :: (a->b) -> (c->d) -> Pair<a, c> -> Pair<b, d>
const bimap = function (f) {
    return function (g) {
        return converge(
            create
        )(
            compose(f)(prop("magnitude"))
        )(
            compose(g)(prop("angle"))
        );
    };
};

const validate = functional_if(
    is_object
)(
    andf(
        compose(gte(0))(prop("magnitude"))
    )(
        compose(type_check("number"))(prop("angle"))
    )
)(
    constant(false)
);

const type_factory = function (ignore) {
    return Object.freeze({
        spec: "curried-static-land",
        version: 1,
        type_name,
        equals,
        concat,
        empty,
        invert,
        map,
        bimap,
        create,
        validate
    });
};

export default Object.freeze(type_factory);
