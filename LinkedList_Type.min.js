/*jslint
    fudge
*/

import {
    compose,
    constant,
//    identity,
    flip
} from "@jlrwi/combinators";
import {
    log,
    prop,
    andf,
    equals,
    is_object,
    object_has_property
} from "@jlrwi/esfunctions";

// Static Land implementation of Array
const type_name = "Linked_List";

const map_thru = function (tail_callback) {
    const mapper = function (f) {
        return function (link) {
            if (link.length === 0) {
                return link;
            }

            return [
                f (link[0]),
                (
                    (link[1] === undefined)
                    ? tail_callback (link[0])
                    : mapper (f) (link[1])
                )
            ];
        };
    };
    return mapper;
};

// Setoid :: a -> a -> boolean
const adt_equals = function (content_type) {
    const is_equal = function (x_link) {
        return function (y_link) {
            if ((x_link === undefined) || (y_link === undefined)) {
                return (x_link === y_link);
            }
            return (
                (content_type.equals (y_link[0]) (x_link[0]))
                ? is_equal (y_link[1]) (x_link[1])
                : false
            );
        };
    };
    return is_equal;
};

// Ord :: a -> a -> Boolean
// true at first index where x[n] < y[n]
// or identical up to identical array lengths or y longer
const lte = function (content_type) {
    const is_lte = function (y_link) {
        return function (x_link) {

            if (x_link === undefined) {
                return true;
            }

            if (y_link === undefined) {
                return false;
            }

            return (
                (content_type.equals (y_link[0]) (x_link[0]))
                ? is_lte (y_link[1]) (x_link[1])
                : content_type.lte (y_link[0]) (x_link[0])
            );
        };
    };
    return is_lte;
};

// Semigroup :: [a] -> [a] -> [a]
const concat = function (ys) {
    return function (xs) {
        const list_join = function (list) {
            if (list[0] === undefined) {
                return xs;
            }
            return [
                list[0],
                (
                    (list[1] === undefined)
                    ? (
                        (xs[0] === undefined)
                        ? undefined
                        : xs
                    )
                    : list_join (list[1])
                )
            ];
        };

        return list_join (ys);
    };
};

// Monoid :: () -> []
const empty = constant (Object.freeze([]));

// Functor :: (a -> b) -> [a] -> [b]
const map = function (f) {
    return function (link) {
        if (link.length === 0) {
            return link;
        }

        return [
            f (link[0]),
            (
                (link[1] === undefined)
                ? undefined
                : map (f) (link[1])
            )
        ];
    };
};

// Apply :: [(a -> b)] -> [a] -> [b]
const ap = function (f_link) {
    return function (x_link) {
        const tail_link = function () {
            return (
                f_link[1] === undefined
                ? undefined
                : ap (f_link[1]) (x_link)
            );
        };

        if (f_link.length === 0) {
            return f_link;
        }

        if (x_link.length === 0) {
            return x_link;
        }

        return map_thru (tail_link) (f_link[0]) (x_link);
    };
};

// Applicative :: x -> [x]
const of = function (x) {
    return Object.freeze([x, undefined]);
};

// Chain :: (a -> [b]) -> [a] -> [b]
const chain = function (f) {
    let res;

    const each = function (link) {
        res = (
            (res === undefined)
            ? f (link[0])
            : concat (res) (f (link[0]))
        );
        return (
            (link[1] === undefined)
            ? res
            : each (link[1])
        );
    };

    return each;
};

// Extend :: ([a] -> b) -> [a] -> [b]
const extend = function (f) {
    return function (xs) {
        return Object.freeze(
            xs.map (function (ignore, idx) {
                return f (xs.slice (idx));
            })
        );
    };
};

// Comonad :: [a] -> a
/* const extract = function (xs) {

    if (xs.length === 0) {
        throw new TypeError("Cannot extract from empty list");
    }

    return xs[0];
}; */

const populate = function () {
    const first_link = [];
    let last_link = [];

    const add_link = function (val) {
        let new_link;

        if (val === undefined) {
            last_link[1] = undefined;
        } else if (first_link.length === 0) {
            first_link[0] = val;
            last_link = first_link;
        } else {
            new_link = [val];
            last_link[1] = new_link;
            last_link = new_link;
        }

        return (
            (val === undefined)
            ? first_link
            : add_link
        );
    };

    return add_link;
};

// Filterable :: (a -> Boolean) -> [a] -> [a]
const filter = function (f) {
    const result = populate ();

    const each = function (x_link) {
        if ((x_link.length > 0) && (f (x_link[0]) === true)) {
            result (x_link[0]);
        }
        return (
            (x_link[1] === undefined)
            ? result ()
            : each (x_link[1])
        );
    };
    return each;
};

// Alt :: [a] -> [a] -> [a]
const alt = concat;

const log_list = map (function (x) {
    log(x);
    return x;
});

// [a] -> a -> [a]
const append = function (list) {
    return function (x) {
        return [x, list];
    };
};

// Foldable :: ((b, a) -> b) -> (_->b) -> [a] -> b
const reduce = function (f) {
    return function (initial) {
        let acc = initial;
        const each = function (x_link) {
            acc = f (acc) (x_link[0]);
            return (
                (x_link[1] === undefined)
                ? acc
                : each (x_link[1])
            );
        };
        return each;
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> [a] -> U<List<b>>
// Concat for this type is expensive because the result list has to be rebuilt
// at each concat. This traverse works impurely under the hood to mutate the
// contents of the returned U<> by adding on values as the original list is
// traversed.
const traverse = function (of_T) {
    return function (f) {
        const head = [];
        let link;                       // Link to current link in list
        let result;                     // The U<List<b>>

// Mapping fx to set contents of U<> to be the germ of our result list
        const initialize_result = function (val) {
            head[0] = val;
            link = head;
            return head;
        };

// Mapping fx to add a link to the contents of U<>
        const build_link = function (val) {
            link[1] = [val];
            link = link[1];
            return head;                // Always return the head of the list
        };

        const each = function (x_link) {
            if (result === undefined) {
// Defined U<List<b>>, Lisb<b> being a reference to a List that will be built
                result = of_T.map (initialize_result) (f (x_link[0]));
            } else {
// The value from f is stolen and the output from .map() is discarded
                of_T.map (build_link) (f (x_link[0]));
            }
            if (x_link[1] === undefined) {
                link[1] = undefined;
            }
            return (
                (x_link[1] === undefined)
                ? result
                : each (x_link[1])
            );
        };
        return each;
/*
        return reduce (function (acc) {
            return function (val) {
                if (acc === undefined) {
                    return of_T.map (of) (f (val));
                }
// Make an apply that's waiting for the acc to concat
//  Apply f to each value from array (which puts it into an applicative),
//  Then use the applicative's map to concat the value to the accumulator's
//      array of values
                return of_T.ap (
                    of_T.map (compose (flip (concat)) (of)) (f (val))
                ) (acc);
            };
        }) ([]);
*/
    };
};

// Plus :: () -> []
const zero = empty;

// Sanctuary has chainRec

/*
const get = function (idx) {
    return prop (idx);
};

const set = function (idx) {
    return function (val) {
        return function (a) {
            return Object.freeze(
                [...a.slice(0, idx), val, ...a.slice(idx + 1)]
            );
        };
    };
};

const indexer = Object.freeze({
    get,
    set
});
*/

const is_array_of_two = andf (
    compose (equals (2)) (prop ("length"))
) (
    Array.isArray
);

const validate = function (predicate) {
    let depth = 0;

    const check_link = function (link) {

        // Empty check
        if (depth === 0 && (Array.isArray(link) && (link.length === 0))) {
            return true;
        }

        // End check
        if (link === undefined) {
            return true;
        }

        depth += 1;

        return (
            (andf (predicate) (is_array_of_two) (link))
            ? check_link (link[1])
            : false
        );
    };

    return check_link;
};

// Takes an array and returns a frozen copy
// Needs self-reference to get name and validate()
const create = of;

// Have to pass a sl type module to get Setoid
const type_factory = function (type_of) {
    const base_type = {
        spec: "StaticLand",
        version: 1,
        type_name,
        alt,
        ap,
        chain,
        extend,
//        extract,
        concat,
        filter,
        map,
        of,
        empty,
        zero,
        append,
        traverse,
        reduce,
//        indexer,
        validate: validate (constant (true)),
        create
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("equals")) {
            base_type.equals = adt_equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (
                compose (type_of.validate) (prop (0))
            );
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

/*
*/

export default Object.freeze(type_factory);
